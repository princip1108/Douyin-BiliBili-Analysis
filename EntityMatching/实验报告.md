# 实体融合实验报告

## 一、实验目的

通过Amazon和Google两个商品数据集，学习并实现基于TF-IDF和余弦相似度的实体匹配算法，理解文本相似度计算的基本原理。

---

## 二、实验环境

- **操作系统**: Windows
- **编程语言**: Python 3
- **开发工具**: Jupyter Notebook
- **主要库**: pandas, re, math, collections, matplotlib

---

## 三、数据集说明

| 数据文件 | 记录数 | 说明 |
|----------|--------|------|
| Amazon.csv | 1363条 | Amazon商品数据 |
| Google.csv | 3226条 | Google商品数据 |
| stopwords.txt | 127个 | 英文停用词表 |
| Amazon_Google_perfectMapping.csv | 1300+对 | 真实匹配标准答案 |

每条商品记录包含：id、title、description、manufacturer、price

---

## 四、算法原理

### 4.1 文本分词(Tokenization)

将商品的title、description、manufacturer合并为文本，使用正则表达式`\w+`进行分词，转换为小写，并去除停用词。

```python
tokens = re.findall(r'\w+', text.lower())
tokens = [t for t in tokens if t not in stopwords]
```

### 4.2 TF-IDF计算

**TF (词频)**：
$$TF(token) = \frac{该token在文档中出现的次数}{文档中的总token数}$$

**IDF (逆文档频率)**：
$$IDF(token) = \frac{文档总数}{包含该token的文档数}$$

**TF-IDF**：
$$TF\text{-}IDF(token) = TF(token) \times IDF(token)$$

### 4.3 余弦相似度

将每个token视为一个维度，计算两个TF-IDF向量的余弦值：

$$cos(\vec{a}, \vec{b}) = \frac{\vec{a} \cdot \vec{b}}{|\vec{a}| \times |\vec{b}|}$$

### 4.4 逆向索引优化

为了加速相似度计算，预先构建：
1. **逆向索引**: token → [包含该token的记录ID列表]
2. **预计算norm**: 每条记录TF-IDF向量的模

这样只需计算有共同token的记录对，大大减少计算量。

---

## 五、实验步骤

1. 读取Amazon.csv和Google.csv数据
2. 读取stopwords.txt停用词表
3. 对每条记录进行分词，生成tokens
4. 计算全局IDF值
5. 计算每条记录的TF-IDF向量和norm
6. 构建Amazon数据集的逆向索引
7. 遍历Google记录，利用逆向索引找到候选匹配，计算余弦相似度
8. 在不同阈值下评估精确率
9. 找出最大精确率及对应阈值

---

## 六、实验结果

### 6.1 相似度对数

计算得到的相似度对数：**约244万对**

### 6.2 精确率-阈值关系

| 阈值范围 | 精确率趋势 |
|----------|------------|
| 0.02-0.50 | 较低，假阳性多 |
| 0.50-0.80 | 逐步上升 |
| 0.80-0.95 | 达到峰值 |
| 0.95-0.99 | 下降，匹配数过少 |

### 6.3 最终结果

| 指标 | 标准答案 | 我们的结果 |
|------|----------|------------|
| **最大精确率** | 0.6438 | 0.6458 |
| **最佳阈值** | 0.93 | 0.81 |

### 6.4 结果分析

我们的结果与标准答案存在差异，主要原因可能包括：

1. **IDF计算方式不同**：标准答案可能分别计算Amazon和Google的IDF后合并，我们采用的是合并后统一计算
2. **浮点数精度**：计算过程中的浮点数精度累积误差
3. **阈值粒度**：我们使用0.01的阈值步长，可能错过更精确的最优点
4. **数据处理细节**：如空值处理、特殊字符处理等微小差异

尽管最佳阈值不同(0.81 vs 0.93)，但最大精确率非常接近(0.6458 vs 0.6438)，说明算法整体实现正确。

---

## 七、精确率曲线图

运行最后一个cell会生成精确率-阈值曲线图，展示不同阈值下的精确率变化趋势。

---

## 八、核心代码说明

### 8.1 分词函数
```python
def tokenize(string):
    tokens = simple_tokenize(string)
    return [t for t in tokens if t not in stopwords]
```

### 8.2 TF-IDF计算
```python
def tfidf(tokens, idfs):
    tf_dict = tf(tokens)
    tfidf_dict = {}
    for token, tf_val in tf_dict.items():
        idf_val = idfs.get(token, 0)
        tfidf_dict[token] = tf_val * idf_val
    return tfidf_dict
```

### 8.3 余弦相似度(通过点积和模计算)
```python
similarity = dotprod(weight1, weight2) / (norm1 * norm2)
```

### 8.4 精确率计算
```python
def precision(threshold):
    truepos(threshold)  # 筛选高于阈值的匹配
    true_positive = len(true_dup_sims) - falsepos(threshold)
    return true_positive / len(true_dup_sims)
```

---

## 九、实验总结

1. 成功实现了基于TF-IDF和余弦相似度的实体匹配算法
2. 理解了逆向索引在加速相似度计算中的作用
3. 通过阈值调优找到了最佳匹配精确率
4. 最大精确率达到**64.58%**，阈值为**0.81**

---

## 十、改进方向

1. 尝试不同的IDF计算公式（如log-IDF）
2. 使用更细粒度的阈值搜索
3. 结合其他特征（如价格、制造商）进行多维度匹配
4. 尝试机器学习方法进行实体匹配
